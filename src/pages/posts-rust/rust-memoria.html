<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nilton F. O. Júnior | Memória</title>

  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../../css/template.css">
</head>

<body>

<article class="container">

  <header class="article-header">
    <p class="article-date">31 Janeiro | 2026</p>
    <h1>Memória</h1>
    <p class="article-summary">Ao longo da nossa carreira, é comum ouvirmos termos como Stack e Heap. Muitas vezes, acabamos deixando esse conhecimento para depois, por acreditar que seja algo exclusivo de 'baixo nível'. Hoje, vou explicar um pouco sobre o layout da memória e mostrar onde esses conceitos — e tantos outros — se encaixam.</p>
  </header>

  <section class="article-content">

    <p>Antes de começarmos, deixo aqui uma imagem ilustrativa do layout de memória. Vamos seguir nosso estudo partindo do endereço mais alto até o mais baixo.</p>

    <figure class="article-image">
        <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria.png" alt="Layout de uma Memória">
        <figcaption>Layout de uma memória
          <br>
          <small><strong>Fonte:</strong> Próprio Autor</small>
        </figcaption>
    </figure>

    <p>Vamos começar estudando por Kernel:</p>
    
    <p>Uma das primeiras coisas que a arquitetura de memória define é o espaço do Sistema Operacional (Kernel Space). Ele ocupa os endereços mais altos para garantir que o 'cérebro' do computador tenha uma área reservada e protegida, permitindo que todos os outros processos funcionem com segurança abaixo dele.</p>
    
    <figure class="article-image">
        <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-kernel.png" alt="Layout de Memória - Kernel">
        <figcaption>Kernel
          <br>
          <small><strong>Fonte:</strong> Próprio Autor</small>
        </figcaption>
    </figure>

    <p>Nosso próximo item é o ambiente:</p>
    
    <p>Com o Kernel já residente na memória, o sistema prepara as variáveis de ambiente. Essas variáveis funcionam como um guia de configuração para os programas, definindo o 'cenário' onde eles serão executados e permitindo que saibam onde encontrar arquivos e recursos do sistema.</p>
 
    <figure class="article-image">
        <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-ambiente.png" alt="Layout de Memória - Ambiente">
        <figcaption>Ambiente
          <br>
          <small><strong>Fonte:</strong> Próprio Autor</small>
        </figcaption>
    </figure>

   <p>Se você entendeu um pouco melhor como funciona o ambiente, agora podemos ir para os argumentos:</p>

   <p>Depois que o sistema inicializa e as variáveis de ambiente são carregadas, a memória organiza os Argumentos, que são as instruções extras que dizem como o programa deve começar.</p>
  
      <figure class="article-image">
          <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-argumentos.png" alt="Layout de Memória - Argumentos">
          <figcaption>Argumentos
            <br>
            <small><strong>Fonte:</strong> Próprio Autor</small>
          </figcaption>
      </figure>

    <p>A quantidade de argumentos vem logo depois, até porque o sistema precisa saber exatamente quantas instruções ele recebeu, garantindo assim que ele processe cada uma delas na ordem certa para tudo funcionar como deveria.</p>
  
      <figure class="article-image">
          <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-qtd-argumentos.png" alt="Layout de Memória - Quantidade de Argumentos">
          <figcaption>Quantidade de Argumentos
            <br>
            <small><strong>Fonte:</strong> Próprio Autor</small>
          </figcaption>
      </figure>

      <p>Agora que entendemos como o sistema se organiza, chegamos aos Dados das Funções. É nesta área que o programa ganha vida, as funções são empilhadas e executadas conforme a necessidade, lembrando que a primeira a ser chamada é a main.</p>

      <figure class="article-image">
          <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-funcoes.png" alt="Layout de Memória - Dados das Funções">
          <figcaption>Quantidade de Argumentos
            <br>
            <small><strong>Fonte:</strong> Próprio Autor</small>
          </figcaption>
      </figure>


      <p>Para facilitar nosso entendimento podemos visualizar esse bloco como uma Pilha (Stack), no topo (endereços mais altos), o sistema injeta o Ambiente e os Argumentos com sua Quantidade (argc). Imediatamente abaixo, a execução começa e a pilha continua crescendo para baixo conforme os Dados das Funções e suas variáveis locais são criadas. Logo, uma estrutura única, onde o contexto do sistema e a execução do código convivem.</p>

      <figure class="article-image">
          <img src="../../assets/images/posts-rust/layout-memoria/layout-memoria-stack.png" alt="Layout de Memória - Pilha (Stack)">
          <figcaption>Quantidade de Argumentos
            <br>
            <small><strong>Fonte:</strong> Próprio Autor</small>
          </figcaption>
      </figure>

      
  
    <div class="code-container">
      <div class="code-header">
        <span>Python</span>
        <button class="copy-btn" onclick="copyCode(this)">Copiar</button>
      </div>

      <pre><code><span class="keyword">def</span> <span class="function">soma</span>(a, b):
    <span class="keyword">return</span> a + b

<span class="comment"># Exemplo de uso</span>
<span class="function">print</span>(<span class="string">"Olá, mundo!"</span>)
resultado = <span class="function">soma</span>(5, 3)
<span class="function">print</span>(f<span class="string">"Resultado: {resultado}"</span>)</code></pre>

    </div>

    <p>O template agora utiliza as variáveis CSS definidas, possui um tema dark consistente, melhor responsividade e transições suaves nos elementos interativos.</p>

  </section>
</article>

<script src="../js/template.js" defer></script>

</body>
</html>
