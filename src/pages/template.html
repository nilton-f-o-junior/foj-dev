<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Guia completo sobre vari√°veis em Rust: entenda mem√≥ria, tipos de dados e conceitos fundamentais">
  <meta name="keywords" content="Rust, programa√ß√£o, vari√°veis, mem√≥ria, tipos de dados">
  <meta name="author" content="Nilton F. O. J√∫nior">
  
  <title>Nilton F. O. J√∫nior | Rust - Vari√°veis</title>

  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="/src/css/main.css">
  <link rel="stylesheet" href="/src/css/template.css">
</head>

<body>
  <header>

    <nav aria-label="Breadcrumb">
      <ol class="breadcrumb">
        <li><a href="/index.html">In√≠cio</a></li>
        <li aria-current="page">Vari√°veis</li>
      </ol>
    </nav>

    <time class="article-date" datetime="2026-03-28">28 Mar√ßo | 2026</time>
    <h1>Template</h1>
    <p class="article-summary">Entenda como o computador armazena informa√ß√µes, o papel das vari√°veis na mem√≥ria e os diferentes tipos de dados em Rust</p>

  </header>

  <main>

    <article class="article-content">

      <section>
        <h2>Introdu√ß√£o</h2>
        <p>Para entender vari√°veis em Rust, precisamos primeiro compreender como o computador funciona. De forma simplificada, um computador tem dois componentes essenciais:</p>

        <dl>
          <dt><strong>Mem√≥ria</strong></dt>
          <dd>Funciona como uma "gaveta" onde armazenamos informa√ß√µes, sejam elas n√∫meros, textos ou imagens</dd>
          
          <dt><strong>Processamento</strong></dt>
          <dd>√â o "c√©rebro" que realiza c√°lculos e manipula os dados guardados na mem√≥ria para gerar um resultado</dd>
        </dl>
      </section>

      <section>
        <h2>O Sistema Bin√°rio</h2>

        <p>Como o computador √© uma m√°quina eletr√¥nica, ele se comunica atrav√©s de sinais el√©tricos: a presen√ßa ou a aus√™ncia de corrente.</p>

        <p>Para traduzir isso para o mundo l√≥gico, utilizamos o <strong>sistema bin√°rio</strong>, composto por apenas dois d√≠gitos: <code>0</code> (desligado) e <code>1</code> (ligado).</p>

        <p>Cada um desses d√≠gitos √© chamado de <strong>bit</strong> (a menor unidade de informa√ß√£o). Combinando esses bits, o computador consegue representar n√∫meros maiores e instru√ß√µes complexas:</p>

        <div class="code-container">
          <div class="code-header">
            <span>Bin√°rio</span>
            <button class="copy-btn" onclick="copyCode(this)" aria-label="Copiar c√≥digo">Copiar</button>
          </div>
          <pre><code>N√∫mero 0: 0
N√∫mero 1: 1
N√∫mero 2: 10
N√∫mero 3: 11
N√∫mero 4: 100
N√∫mero 5: 101</code></pre>
        </div>

        <h3>De Bits a Bytes</h3>

        <p>A unidade b√°sica √© o Bit, mas para representar informa√ß√µes mais complexas, combinamos <strong>8 bits</strong> para formar um <strong>Byte</strong>.</p>

        <p>Imagine um Byte como uma sequ√™ncia de 8 interruptores. Se todos estiverem desligados (<code>00000000</code>), temos o n√∫mero 0. Se apenas o √∫ltimo estiver ligado (<code>00000001</code>), temos o n√∫mero 1. A maior combina√ß√£o poss√≠vel √© quando todos os 8 bits est√£o ligados (<code>11111111</code>), o que representa o n√∫mero 255.</p>

        <!-- Tabela de convers√£o -->
        <table>
          <caption>Tabela de Convers√£o: Bin√°rio para Decimal</caption>
          <thead>
            <tr>
              <th scope="col">Bin√°rio (8 bits)</th>
              <th scope="col">Decimal</th>
              <th scope="col">Descri√ß√£o</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>00000000</code></td>
              <td>0</td>
              <td>Todos os bits desligados</td>
            </tr>
            <tr>
              <td><code>00000001</code></td>
              <td>1</td>
              <td>Apenas o √∫ltimo bit ligado</td>
            </tr>
            <tr>
              <td><code>00001111</code></td>
              <td>15</td>
              <td>Quatro bits ligados</td>
            </tr>
            <tr>
              <td><code>11111111</code></td>
              <td>255</td>
              <td>Todos os bits ligados (valor m√°ximo)</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
        <h2>O Conceito de Vari√°veis</h2>

        <p>De forma simples, uma vari√°vel √© um espa√ßo reservado na mem√≥ria para armazenar valores. Como o pr√≥prio nome diz, o conte√∫do desse espa√ßo pode <em>"variar"</em> ao longo do tempo, mas o <em>"r√≥tulo"</em> que damos a ele permanece o mesmo.</p>

        <h3>Analogia do Arm√°rio</h3>

        <p>Para entender como isso funciona na pr√°tica, imagine a mem√≥ria do computador como um grande arm√°rio cheio de gavetas. Inicialmente, essas gavetas est√£o vazias e n√£o possuem nenhuma etiqueta.</p>

        <figure class="article-image">
          <img src="../../assets/images/posts-rust/variaveis/rust-variaveis-img-01.png" 
               alt="Ilustra√ß√£o de um arm√°rio com 16 gavetas vazias sem etiquetas"
               loading="lazy">
          <figcaption>
            Representa√ß√£o da mem√≥ria inicial vazia.
            <br>
            <small><strong>Fonte:</strong> Pr√≥prio Autor</small>
          </figcaption>
        </figure>

        <p>Se voc√™ decidir guardar tr√™s informa√ß√µes diferentes, sua tend√™ncia natural seria coloc√°-las em gavetas sequenciais (uma ao lado da outra) para manter a organiza√ß√£o.</p>

        <figure class="article-image">
          <img src="../../assets/images/posts-rust/variaveis/rust-variaveis-img-02.png"
               alt="Arm√°rio com tr√™s gavetas sequenciais preenchidas com dados"
               loading="lazy">
          <figcaption>
            Organiza√ß√£o ideal: dados em endere√ßos vizinhos.
            <br>
            <small><strong>Fonte:</strong> Pr√≥prio Autor</small>
          </figcaption>
        </figure>

        <p>No entanto, o computador nem sempre consegue fazer isso. Como muitos programas rodam ao mesmo tempo, as gavetas vizinhas podem j√° estar ocupadas. Por isso, os dados acabam ficando espalhados em lugares distintos do "arm√°rio".</p>

        <figure class="article-image">
          <img src="../../assets/images/posts-rust/variaveis/rust-variaveis-img-03.png" 
               alt="Arm√°rio com dados espalhados em gavetas n√£o sequenciais"
               loading="lazy">
          <figcaption>
            Mem√≥ria fragmentada: dados ocupando espa√ßos dispon√≠veis aleat√≥rios.
            <br>
            <small><strong>Fonte:</strong> Pr√≥prio Autor</small>
          </figcaption>
        </figure>

        <aside class="note">
          <p><strong>üí° Observa√ß√£o:</strong> Agora, imagine que em vez de 16 gavetas, tiv√©ssemos 45 ou at√© milh√µes delas. Ficaria imposs√≠vel lembrar de cabe√ßa onde cada dado foi guardado, certo?</p>
        </aside>

        <figure class="article-image">
          <img src="../../assets/images/posts-rust/variaveis/rust-variaveis-img-04.png"
               alt="Representa√ß√£o visual de um grande arm√°rio com m√∫ltiplas gavetas"
               loading="lazy">
          <figcaption>
            O desafio de gerenciar grandes volumes de dados.
            <br>
            <small><strong>Fonte:</strong> Pr√≥prio Autor</small>
          </figcaption>
        </figure>

        <h3>Endere√ßamento de Mem√≥ria</h3>

        <p>Para resolver esse caos, a mem√≥ria utiliza <strong>endere√ßos</strong>. Cada gaveta possui um c√≥digo √∫nico e exclusivo. Assim, o computador n√£o apenas guarda a informa√ß√£o, mas registra exatamente em qual "<strong>endere√ßo</strong>" ela foi colocada para poder busc√°-la depois.</p>

        <figure class="article-image">
          <img src="../../assets/images/posts-rust/variaveis/rust-variaveis-img-05.png" 
               alt="Arm√°rio com gavetas identificadas por endere√ßos hexadecimais"
               loading="lazy">
          <figcaption>
            Endere√ßos √∫nicos identificando cada posi√ß√£o na mem√≥ria.
            <br>
            <small><strong>Fonte:</strong> Pr√≥prio Autor</small>
          </figcaption>
        </figure>

        <p>Um detalhe crucial: na mem√≥ria, cada gaveta suporta exatamente <strong>1 Byte</strong>. Se a informa√ß√£o que voc√™ quer guardar for pequena, ela ocupa uma gaveta. Mas, se a informa√ß√£o for grande (como uma foto ou um texto longo), o sistema a divide em peda√ßos e ocupa duas, tr√™s ou quantas gavetas forem necess√°rias para armazenar o dado completo.</p>

        <div class="code-container">
          <div class="code-header">
            <span>Estrutura de um Dado na Mem√≥ria</span>
            <button class="copy-btn" onclick="copyCode(this)" aria-label="Copiar c√≥digo">Copiar</button>
          </div>
          <pre><code>1 Byte = [00000000]
Endere√ßo = 0xCB20
[00000000] + 0xCB20 = Dado</code></pre>
        </div>
      </section>

      <section>
        <h2>Tipos de Dados</h2>

        <p>Essa analogia do arm√°rio ajuda a entender como a mem√≥ria organiza a informa√ß√£o. Na pr√°tica, o resultado desse armazenamento √© o que chamamos de dado. Para facilitar a manipula√ß√£o desses dados, n√≥s os classificamos em tr√™s tipos principais:</p>

        <ol>
          <li><strong>Escalares (ou Primitivos):</strong> um valor √∫nico e simples. Exemplos incluem:
            <ul>
              <li><code>int</code> - n√∫meros inteiros</li>
              <li><code>float</code> - n√∫meros decimais</li>
              <li><code>bool</code> - verdadeiro ou falso</li>
              <li><code>char</code> - um √∫nico caractere</li>
            </ul>
          </li>
          
          <li>Compostos (ou Estruturados): cole√ß√µes que agrupam v√°rios dados em uma √∫nica estrutura:
            <ul>
              <li><code>Arrays</code> - listas de tamanho fixo</li>
              <li><code>Tuplas</code> - agrupamentos de tipos diferentes</li>
              <li><code>Structs</code> - estruturas personalizadas</li>
            </ul>
          </li>
        </ol>

        <h3>Compara√ß√£o de Tipos Primitivos em Rust</h3>
        
        <table>
          <caption>Principais Tipos de Dados Escalares</caption>
          <thead>
            <tr>
              <th scope="col">Tipo</th>
              <th scope="col">Tamanho</th>
              <th scope="col">Intervalo</th>
              <th scope="col">Exemplo</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>i8</code></td>
              <td>8 bits</td>
              <td>-128 a 127</td>
              <td><code>let x: i8 = -42;</code></td>
            </tr>
            <tr>
              <td><code>u8</code></td>
              <td>8 bits</td>
              <td>0 a 255</td>
              <td><code>let x: u8 = 255;</code></td>
            </tr>
            <tr>
              <td><code>i32</code></td>
              <td>32 bits</td>
              <td>-2¬≥¬π a 2¬≥¬π-1</td>
              <td><code>let x: i32 = 1000;</code></td>
            </tr>
            <tr>
              <td><code>f64</code></td>
              <td>64 bits</td>
              <td>¬±1.7E-308 a ¬±1.7E+308</td>
              <td><code>let x: f64 = 3.14;</code></td>
            </tr>
            <tr>
              <td><code>bool</code></td>
              <td>8 bits</td>
              <td>true ou false</td>
              <td><code>let x: bool = true;</code></td>
            </tr>
            <tr>
              <td><code>char</code></td>
              <td>32 bits</td>
              <td>Unicode</td>
              <td><code>let x: char = 'A';</code></td>
            </tr>
          </tbody>
        </table>

        <h3>Declarando Vari√°veis em Rust</h3>

        <div class="code-container">
          <div class="code-header">
            <span>Rust</span>
            <button class="copy-btn" onclick="copyCode(this)" aria-label="Copiar c√≥digo">Copiar</button>
          </div>
          <pre><code>// Vari√°vel imut√°vel (padr√£o em Rust)
let nome = "Nilton";

// Vari√°vel mut√°vel (pode ser alterada)
let mut idade = 25;
idade = 26; // Ok

// Com tipo expl√≠cito
let altura: f64 = 1.75;

// Constante (sempre imut√°vel)
const MAX_PONTOS: u32 = 100_000;</code></pre>
        </div>

        <aside class="warning">
          <h4>‚ö†Ô∏è Importante sobre Mutabilidade</h4>
          <p>Por padr√£o, todas as vari√°veis em Rust s√£o <strong>imut√°veis</strong>. Isso √© uma escolha de design da linguagem para aumentar a seguran√ßa e evitar bugs. Para tornar uma vari√°vel mut√°vel, voc√™ deve usar explicitamente a palavra-chave <code>mut</code>.</p>
        </aside>
      </section>

      <p>Caso queira continuar estudando e aprender mais sobre outros conte√∫dos, <a href="/index.html">segue o link</a>. Bons estudos!</p>

      <blockquote class="quote">
        <p>"<em>A beleza que vive no ato de compartilhar algo com o outro.</em>" ‚Äî <cite>Monja Coen</cite></p>
      </blockquote>

    </article>
  </main>

  <footer>
    <p>Nilton F. O. J√∫nior</p>
  </footer>

  <script src="../js/template.js" defer></script>

</body>

</html>